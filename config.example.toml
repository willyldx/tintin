[bot]
name = "codexbot"
host = "0.0.0.0"
port = 8787
data_dir = "./data"
log_level = "info"
# 1=response only, 2=response+reasoning+events (no tool call output), 3=all messages
message_verbosity = 3

[db]
# sqlite (SQLAlchemy-style URL):
url = "sqlite+aiosqlite:///./data/codexbot.db"
echo = false

[security]
restrict_paths = true
allow_roots = ["/srv/repos", "/home/agent/projects"]
deny_globs = ["**/.git/**", "**/.env", "**/secrets/**"]
max_sessions_per_chat = 20
max_concurrent_sessions_per_chat = 2
# Optional allowlists (empty => allow all)
# telegram_allow_user_ids = [123456789]
# telegram_allow_chat_ids = [-1001234567890]
# telegram_require_admin = false
# slack_allow_user_ids = ["U012ABCDEF"]
# slack_allow_channel_ids = ["C012ABCDEF"]
# slack_allow_workspace_ids = ["T012ABCDEF"]

[codex]
binary = "codex"
sessions_dir = ".codex/sessions"
poll_interval_ms = 500
max_catchup_lines = 2000
timeout_seconds = 3600
env = { "CODEX_TELEMETRY" = "0" }

[[projects]]
id = "api"
name = "API Service"
path = "/srv/repos/api"

[[projects]]
id = "custom"
name = "Custom pathâ€¦"
path = "*"

[telegram]
token = "env:TELEGRAM_TOKEN"
# Optional extra bots used only for sending to reduce rate limiting; first token above is still used for updates/webhooks.
# additional_bot_tokens = ["env:TELEGRAM_TOKEN_2", "env:TELEGRAM_TOKEN_3"]
mode = "webhook" # webhook | poll
public_base_url = "https://bot.example.com"
webhook_path = "/tg/webhook"
webhook_secret_token = "env:TELEGRAM_WEBHOOK_SECRET"
poll_timeout_seconds = 30
use_topics = true
max_chars = 3500
message_queue_interval_ms = 3000
rate_limit_msgs_per_sec = 1.0

[slack]
bot_token = "env:SLACK_BOT_TOKEN"
signing_secret = "env:SLACK_SIGNING_SECRET"
events_path = "/slack/events"
interactions_path = "/slack/interactions"
session_mode = "thread"
max_chars = 3000
rate_limit_msgs_per_sec = 1.0
